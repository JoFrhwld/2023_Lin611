{
  "hash": "3c643a08fef9a125764b8d120466b647",
  "result": {
    "markdown": "---\ntitle: \"Mixed Effects Models 1\"\ndate: 2023-04-06\nknitr: \n  opts_chunk: \n    message: false\ncode-annotations: hover\n---\n\n\n## Setup\n\n### Installing new packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif(!require(broom.mixed)){\n  install.packages(\"broom.mixed\")\n  library(broom.mixed)\n}\n\nif(!require(lme4)){\n  install.packages(\"lme4\")\n  library(lme4)\n}\n\nif(!require(janitor)){\n  install.packages(\"janitor\")\n  library(janitor)\n}\n```\n:::\n\n\n### Loading already installed packages\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(marginaleffects)\nlibrary(tidyverse)\n```\n:::\n\n\n### Loading data for today\n\n\n::: {.cell}\n\n```{.r .cell-code}\ney_dat <- read_csv(\"https://bit.ly/ey_dat\")\n```\n:::\n\n\n## Looking at the data\n\nImbalance is going to be rampant!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ney_dat |>                       \n  count(speaker) |>             #<1>\n  mutate(                       #<2>\n    rank = rank(                #<3>\n      desc(n),                  #<4>  \n      ties.method = \"random\"    #<5>\n    )                           \n  ) |> \n  ggplot(aes(rank, n))+\n    geom_col()+\n    labs(\n      title = \"data per speaker\"\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n1.  Getting the total number of observations per speaker.\n2.  Adding on a column.\n3.  Getting the rank of `n`, the number of observations.\n4.  We want the descending rank (that is, the largest `n` should get 1.\n5.  When two or more speakers have the same `n`, randomly assign the next rank, rather than giving them all the same rank.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ney_dat |> \n  count(word) |> \n  mutate(\n    rank = rank(\n      desc(n),\n      ties.method = \"random\"\n    )\n  ) |> \n  ggplot(aes(rank, n))+\n    geom_col()+\n    labs(\n      title = \"data per word\"\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n## Prepare the data for modelling\n\n\n::: {.cell}\n\n```{.r .cell-code}\ney_dat |> \n  mutate(\n    dob_0 = (dob - median(dob))/25,\n    log_freq = log2(frequency),\n    freq_c = log_freq - median(log_freq),\n    log_dur = log2(dur),\n    dur_c = log_dur - median(log_dur)\n  ) |> \n  drop_na()->\n  ey_to_model\n```\n:::\n\n\n## Modelling\n\n### \"Complete Pooling\"\n\nThat is, pooling all speakers' data together.\n\nQ: What is the effect of word frequency on `F1_n`?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ney_flat <- lm(F1_n ~ freq_c, data = ey_to_model)\n```\n:::\n\n\n#### The model parameters\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(ey_flat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  term        estimate std.error statistic  p.value\n  <chr>          <dbl>     <dbl>     <dbl>    <dbl>\n1 (Intercept)  -0.384    0.00352    -109.  0       \n2 freq_c        0.0126   0.00126      10.0 1.60e-23\n```\n:::\n:::\n\n\n#### The fitted values\n\nStep 1, get a reasonable range of `freq_c` values to get predictions between.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfreq_range <- quantile(\n  ey_to_model$freq_c, \n  probs = c(0.025, 0.975)\n)\n\nfreq_range\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     2.5%     97.5% \n-6.306671  3.563938 \n```\n:::\n:::\n\n\nStep 2, get the predictions\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredictions(               #<1>\n  model = ey_flat,         #<2>\n  newdata = datagrid(      #<3>\n    freq_c = seq(freq_range[1], freq_range[2], length = 50) #<4>\n  )\n)  |> \n  as_tibble() ->         #<5>\n  ey_flat_predicted\n```\n:::\n\n\n1.  `marginaleffects::predictions()`\n2.  The model we're getting predicted values from.\n3.  Using `marginaleffects::datagrid()` to create an \"grid\" of data to make predictions for.\n4.  We want predictions from the beginning to the end of `freq_range` with 50 total predictions.\n5.  Converting the result to a tibble.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ney_flat_predicted |> \n  ggplot(aes(freq_c, estimate))+\n    geom_ribbon(\n      aes(ymin = conf.low, ymax = conf.high),\n      alpha = 0.6\n    )+\n    geom_line()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n### No Pooling\n\nOne model per speaker.\n\n#### Fitting the models\n\nStep 1: \"Nest\" the speaker data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ney_to_model |> \n  group_by(speaker) |> \n  nest() -> \n  ey_nested\n\nhead(ey_nested)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 2\n# Groups:   speaker [6]\n  speaker   data               \n  <chr>     <list>             \n1 PH00-1-1- <tibble [110 × 15]>\n2 PH00-1-2- <tibble [141 × 15]>\n3 PH00-1-3- <tibble [192 × 15]>\n4 PH00-1-4- <tibble [125 × 15]>\n5 PH00-1-5- <tibble [204 × 15]>\n6 PH02-1-1- <tibble [62 × 15]> \n```\n:::\n:::\n\n\nStep 2: Write a little function to fit a linear model to a data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfit_lm <- function(df){\n  lm(F1_n ~ freq_c, data = df)\n}\n```\n:::\n\n\nStep 3: `purrr:map()` that function over the `data` column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ney_nested |> \n  mutate(models = map(data, fit_lm)) ->\n  ey_nested_models\n\nhead(ey_nested_models)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 3\n# Groups:   speaker [6]\n  speaker   data                models\n  <chr>     <list>              <list>\n1 PH00-1-1- <tibble [110 × 15]> <lm>  \n2 PH00-1-2- <tibble [141 × 15]> <lm>  \n3 PH00-1-3- <tibble [192 × 15]> <lm>  \n4 PH00-1-4- <tibble [125 × 15]> <lm>  \n5 PH00-1-5- <tibble [204 × 15]> <lm>  \n6 PH02-1-1- <tibble [62 × 15]>  <lm>  \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ney_nested_models$models[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = F1_n ~ freq_c, data = df)\n\nCoefficients:\n(Intercept)       freq_c  \n   -0.65156      0.03696  \n```\n:::\n:::\n\n\n#### Getting the model parameters\n\nStep 1: map `tidy` onto each model and unnest it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ney_nested_models |> \n  mutate(\n    params = map(models, tidy)\n  ) |> \n  unnest(params) ->\n  ey_nested_params\n\nhead(ey_nested_params)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 8\n# Groups:   speaker [3]\n  speaker   data                models term    estimate std.e…¹ stati…²  p.value\n  <chr>     <list>              <list> <chr>      <dbl>   <dbl>   <dbl>    <dbl>\n1 PH00-1-1- <tibble [110 × 15]> <lm>   (Inter… -0.652    0.0469 -13.9   8.20e-26\n2 PH00-1-1- <tibble [110 × 15]> <lm>   freq_c   0.0370   0.0177   2.09  3.88e- 2\n3 PH00-1-2- <tibble [141 × 15]> <lm>   (Inter… -0.455    0.0448 -10.1   1.93e-18\n4 PH00-1-2- <tibble [141 × 15]> <lm>   freq_c  -0.00526  0.0149  -0.354 7.24e- 1\n5 PH00-1-3- <tibble [192 × 15]> <lm>   (Inter… -0.436    0.0308 -14.1   1.64e-31\n6 PH00-1-3- <tibble [192 × 15]> <lm>   freq_c  -0.00573  0.0120  -0.478 6.33e- 1\n# … with abbreviated variable names ¹​std.error, ²​statistic\n```\n:::\n:::\n\n\nStep 2: Select the columns of interest, and pivot wider\n\n\n::: {.cell}\n\n```{.r .cell-code}\ney_nested_params |> \n  mutate(\n    n = map_vec(data, nrow)\n  ) |> \n  select(speaker, n, term, estimate) |> \n  pivot_wider(\n    names_from = term,\n    values_from = estimate\n  ) |> \n  janitor::clean_names() ->\n  ey_speaker_params\n\nhead(ey_speaker_params)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n# Groups:   speaker [6]\n  speaker       n intercept   freq_c\n  <chr>     <int>     <dbl>    <dbl>\n1 PH00-1-1-   110   -0.652   0.0370 \n2 PH00-1-2-   141   -0.455  -0.00526\n3 PH00-1-3-   192   -0.436  -0.00573\n4 PH00-1-4-   125   -0.682   0.0362 \n5 PH00-1-5-   204   -0.238   0.0316 \n6 PH02-1-1-    62   -0.0987 -0.0313 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ney_speaker_params |> \n  ggplot(aes(intercept, freq_c))+\n    geom_point(\n      aes(size = n),\n      alpha = 0.6\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n#### Getting predictions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_pred_tibble <- function(mod, freq_range){\n  predictions(\n    mod,\n    newdata = datagrid(\n      freq_c = seq(freq_range[1], freq_range[2], length = 10) \n    )\n  ) |> \n    as_tibble()\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ney_nested_models |> \n  mutate(\n    n = map_vec(data, nrow),\n    pred = map(models, get_pred_tibble)\n  ) |> \n  select(speaker, n, pred) |> \n  unnest(pred)->\n  pred_by_speaker\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npred_by_speaker |> \n  ggplot(aes(freq_c, estimate))+\n    geom_line(\n      aes(group = speaker),\n      alpha = 0.2\n    )+\n    geom_line(\n      data = ey_flat_predicted,\n      color = \"steelblue\",\n      linewidth = 2\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\n### Partial Pooling\n\na.k.a. mixed effects model.\n\n#### Specifying and fitting the model\n\n\n::: {.cell}\n\n```{.r .cell-code}\ney_mixed <- lmer(F1_n ~ freq_c + (1 + freq_c | speaker), data = ey_to_model)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(ey_mixed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinear mixed model fit by REML ['lmerMod']\nFormula: F1_n ~ freq_c + (1 + freq_c | speaker)\n   Data: ey_to_model\n\nREML criterion at convergence: 30304.5\n\nScaled residuals: \n     Min       1Q   Median       3Q      Max \n-13.9927  -0.6526  -0.0698   0.5733   8.4810 \n\nRandom effects:\n Groups   Name        Variance  Std.Dev. Corr\n speaker  (Intercept) 0.0515319 0.22701      \n          freq_c      0.0002979 0.01726  0.01\n Residual             0.2188022 0.46776      \nNumber of obs: 22269, groups:  speaker, 286\n\nFixed effects:\n             Estimate Std. Error t value\n(Intercept) -0.352428   0.014030 -25.120\nfreq_c       0.011797   0.001658   7.116\n\nCorrelation of Fixed Effects:\n       (Intr)\nfreq_c 0.038 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(ey_mixed)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 6\n  effect   group    term                    estimate std.error statistic\n  <chr>    <chr>    <chr>                      <dbl>     <dbl>     <dbl>\n1 fixed    <NA>     (Intercept)             -0.352     0.0140     -25.1 \n2 fixed    <NA>     freq_c                   0.0118    0.00166      7.12\n3 ran_pars speaker  sd__(Intercept)          0.227    NA           NA   \n4 ran_pars speaker  cor__(Intercept).freq_c  0.00538  NA           NA   \n5 ran_pars speaker  sd__freq_c               0.0173   NA           NA   \n6 ran_pars Residual sd__Observation          0.468    NA           NA   \n```\n:::\n:::\n\n\nCompare to the flat model\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(ey_flat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 × 5\n  term        estimate std.error statistic  p.value\n  <chr>          <dbl>     <dbl>     <dbl>    <dbl>\n1 (Intercept)  -0.384    0.00352    -109.  0       \n2 freq_c        0.0126   0.00126      10.0 1.60e-23\n```\n:::\n:::\n\n\n#### Comparison to the no-pooling models\n\n\n::: {.cell}\n\n```{.r .cell-code}\nranef(ey_mixed)$speaker |> \n  janitor::clean_names() |>\n  rownames_to_column(\"speaker\") |> \n  mutate(\n    intercept = intercept + fixef(ey_mixed)[1],\n    freq_c = freq_c + fixef(ey_mixed)[2]\n  )->\n  mixed_speaker_params\n\nmixed_speaker_params |> \n  ggplot(aes(intercept, freq_c))+\n    geom_point()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n\n#### Getting predictions\n\nFor each speaker\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredictions(\n  ey_mixed,\n  newdata = datagrid(\n    freq_c = seq(freq_range[1], freq_range[2], length = 10),\n    speaker = unique(ey_dat$speaker)\n  )\n) |> \n  as_tibble() ->\n  mixed_group_pred\n```\n:::\n\n\nJust the fixed effects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredictions(\n  ey_mixed,\n  re.form = NA,\n  newdata = datagrid(\n    freq_c = seq(freq_range[1], freq_range[2], length = 10)\n  )\n) |> \n  as_tibble()->\n  mixed_fixed_pred\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmixed_group_pred |> \n  ggplot(aes(freq_c, estimate))+\n    geom_line(\n      aes(group = speaker),\n      alpha = 0.3\n    )+\n    geom_line(\n      data = mixed_fixed_pred,\n      color = \"steelblue\",\n      linewidth = 2\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n## More than one grouping factor\n\nYou couldn't look at *both* speaker and word grouping effects in the no-pooling approach\n\n\n::: {.cell}\n\n```{.r .cell-code}\ney_mixed2 <- lmer(F1_n ~ freq_c + (1 + freq_c | speaker) + (1 | word), data = ey_to_model)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(ey_mixed2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLinear mixed model fit by REML ['lmerMod']\nFormula: F1_n ~ freq_c + (1 + freq_c | speaker) + (1 | word)\n   Data: ey_to_model\n\nREML criterion at convergence: 27050.8\n\nScaled residuals: \n     Min       1Q   Median       3Q      Max \n-15.5631  -0.6201  -0.0521   0.5600   9.6964 \n\nRandom effects:\n Groups   Name        Variance  Std.Dev. Corr\n word     (Intercept) 0.0525761 0.2293       \n speaker  (Intercept) 0.0495451 0.2226       \n          freq_c      0.0002073 0.0144   0.15\n Residual             0.1819768 0.4266       \nNumber of obs: 22269, groups:  word, 735; speaker, 286\n\nFixed effects:\n             Estimate Std. Error t value\n(Intercept) -0.365703   0.023929 -15.283\nfreq_c       0.006999   0.004179   1.675\n\nCorrelation of Fixed Effects:\n       (Intr)\nfreq_c 0.672 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntidy(ey_mixed2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 6\n  effect   group    term                    estimate std.error statistic\n  <chr>    <chr>    <chr>                      <dbl>     <dbl>     <dbl>\n1 fixed    <NA>     (Intercept)             -0.366     0.0239     -15.3 \n2 fixed    <NA>     freq_c                   0.00700   0.00418      1.67\n3 ran_pars word     sd__(Intercept)          0.229    NA           NA   \n4 ran_pars speaker  sd__(Intercept)          0.223    NA           NA   \n5 ran_pars speaker  cor__(Intercept).freq_c  0.154    NA           NA   \n6 ran_pars speaker  sd__freq_c               0.0144   NA           NA   \n7 ran_pars Residual sd__Observation          0.427    NA           NA   \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nranef(ey_mixed2)$word |> \n  janitor::clean_names() |> \n  rownames_to_column() |> \n  arrange(intercept) |> \n  head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      rowname  intercept\n1 association -0.4122733\n2        gave -0.3925951\n3        gate -0.3473580\n4       waste -0.3430363\n5   radiation -0.3422552\n6         hat -0.3366734\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}