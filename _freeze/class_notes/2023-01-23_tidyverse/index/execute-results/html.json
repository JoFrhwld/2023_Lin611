{
  "hash": "d83955ef2f082e10ce2b8bd9310e7b5e",
  "result": {
    "markdown": "---\ntitle: \"Starting with the tidyverse\"\n---\n\n\nLet's start by loading the tidyverse.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   1.0.0 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.4.1 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n:::\n\n\n## Tidyverse functions as verbs\n\nMost tidyverse functions are written to be *verbs*, taje a data frame as their first argument, and also return a data frame.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# a data frame\nmtcars <- as_tibble(mtcars)\nmtcars\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 × 11\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# … with 22 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# filter the dataframe to \n# only the rows with cyl==6\nfilter(mtcars, cyl == 6)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 × 11\n    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n3  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n4  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n5  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n6  17.8     6  168.   123  3.92  3.44  18.9     1     0     4     4\n7  19.7     6  145    175  3.62  2.77  15.5     0     1     5     6\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# count how many rows \n# have these values of gears\ncount(mtcars, gear)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n   gear     n\n  <dbl> <int>\n1     3    15\n2     4    12\n3     5     5\n```\n:::\n:::\n\n\n## Piping\n\nSince tidyverse functions take data frames as input, and produce data frames as output, you might want to combine them.\n\n*What are the counts of `gear` for cars with `cyl==6`?*\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount(\n  filter(\n    mtcars, \n    cyl == 6\n    ), \n  gear\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n   gear     n\n  <dbl> <int>\n1     3     2\n2     4     4\n3     5     1\n```\n:::\n:::\n\n\nA problem here is that you have to write, and read your functions inside out. Wouldn't it be great if we could write code that looks like:\n\n> First take the `mtcars` data, and then filter it by `cyl==6`, then get the count of gears.\n\nThat's where the pipe `|>` comes in. The pipe takes everything to its left, and inserts it as the first argument to the function on its right.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this\nmtcars |> filter(cyl == 6)\n\n# is equivalent to this\nfilter(mtcars, cyl == 6)\n```\n:::\n\n\nThis lets us chain tidyverse verbs together.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> \n  filter(cyl == 6) |> \n  count(gear)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n   gear     n\n  <dbl> <int>\n1     3     2\n2     4     4\n3     5     1\n```\n:::\n:::\n\n\n::: callout-note\n## Work it out\n\nThe dataframe `starwars` contains demographic and personal data for many characters from the Star Wars universe. Using `dplyr` verbs like\n\n-   [`filter()`](https://dplyr.tidyverse.org/reference/filter.html)\n\n-   [`count()`](https://dplyr.tidyverse.org/reference/count.html)\n\n-   [`arrange()`](https://dplyr.tidyverse.org/reference/arrange.html)\n\n-   [`slice()`](https://dplyr.tidyverse.org/reference/slice.html)\n\n-   [`select()`](https://dplyr.tidyverse.org/reference/select.html)\n\n1.  Find out which planet is the most common homeworld for humans.\n2.  Find out who was the tallest Droid.\n:::\n\n## Grouping and summarizing\n\nTo find out average horsepower across all of the cars in `mtcars`, we can use `summarise()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> \n  summarise(hp = mean(hp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1 × 1\n     hp\n  <dbl>\n1  147.\n```\n:::\n:::\n\n\nIf we wanted to find out the average horsepower by the number of cylinders, we can `group_by()` and then `summarise()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars |> \n  group_by(cyl) |> \n  summarise(hp = mean(hp))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 2\n    cyl    hp\n  <dbl> <dbl>\n1     4  82.6\n2     6 122. \n3     8 209. \n```\n:::\n:::\n\n\n## Mutating\n\nTo add new columns to a data frame, we can use `mutate()`. Inside of mutate, we can make reference to any column in the dataframe.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## horsepower by cylinder?\nmtcars |> \n  mutate(hp_by_cyl = hp/cyl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 32 × 12\n     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb hp_by_cyl\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>     <dbl>\n 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4      18.3\n 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4      18.3\n 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1      23.2\n 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1      18.3\n 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2      21.9\n 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1      17.5\n 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4      30.6\n 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2      15.5\n 9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2      23.8\n10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4      20.5\n# … with 22 more rows\n```\n:::\n:::\n\n\n::: callout-note\n## Work it out\n\nThis will load all tokens of \"uh\" and \"um\" from the Philadelphia Neighborhood Corpus.\n\n\n::: {.cell}\n\n```{.r .cell-code}\num <- read_tsv(\"https://bit.ly/3JdeSbx\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 26060 Columns: 14\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr  (3): word, next_seg, idstring\ndbl (11): start_time, end_time, vowel_start, vowel_end, nasal_start, nasal_e...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\nThe column `word` codes whether it was \"um\" or \"uh\" or some combo that was spoken. Other important columns are\n\n-   `start_time`, `end_time`: the start and end times for the whole word\n\n-   `vowel_start`, `vowel_end`: The start and end time of the vowel in the word.\n\n-   `nasal_start`, `nasal_end`: The start and end times of the nasal, for the word `UM`.\n\n-   `next_seg`: the transcription of the following segment. `\"sp\"` means \"pause\"\n\n-   `next_seg_start`, `next_seg_end` the start and end times of the following segment\n\n\n::: {.cell}\n\n```{.r .cell-code}\num\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 26,060 × 14\n   word  start…¹ end_t…² vowel…³ vowel…⁴ nasal…⁵ nasal…⁶ next_…⁷ next_…⁸ next_…⁹\n   <chr>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl> <chr>     <dbl>   <dbl>\n 1 UH       24.4    24.7    24.4    24.7    NA      NA   S          24.7    24.9\n 2 UH       35.0    35.2    35.0    35.2    NA      NA   F          35.2    35.4\n 3 UM       37.9    38.3    37.9    38.1    38.1    38.3 sp         38.3    38.4\n 4 UH       44.5    44.7    44.5    44.7    NA      NA   DH         44.7    44.7\n 5 UH       57.6    57.8    57.6    57.8    NA      NA   AY1        57.8    57.9\n 6 UH       62.3    62.5    62.3    62.5    NA      NA   sp         62.5    63.0\n 7 UH       73.9    74.2    73.9    74.2    NA      NA   sp         74.2    75.0\n 8 UH       75.1    75.4    75.1    75.4    NA      NA   sp         75.4    75.7\n 9 UM       81.6    82.0    81.6    81.8    81.8    82.0 sp         82.0    84.0\n10 UH       92.6    92.9    92.6    92.9    NA      NA   sp         92.9    93.4\n# … with 26,050 more rows, 4 more variables: chunk_start <dbl>,\n#   chunk_end <dbl>, nwords <dbl>, idstring <chr>, and abbreviated variable\n#   names ¹​start_time, ²​end_time, ³​vowel_start, ⁴​vowel_end, ⁵​nasal_start,\n#   ⁶​nasal_end, ⁷​next_seg, ⁸​next_seg_start, ⁹​next_seg_end\n```\n:::\n:::\n\n\nUsing dplyr verbs like\n\n-   `mutate()`\n\n-   `group_by()`\n\n-   `summarise()`\n\n1.  Figure out the average duration of the vowel for each kind of `word`.\n2.  Figure out the average duration of the vowel for each kind of `word` when the following segment is a pause versus when it isn't.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}