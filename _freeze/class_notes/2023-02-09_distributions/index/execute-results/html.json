{
  "hash": "67dc814354b6236b475340348e15a8dc",
  "result": {
    "markdown": "---\ntitle: \"Distributions 2\"\ndate: 2023-02-09\norder: 10\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0     ✔ purrr   1.0.1\n✔ tibble  3.1.8     ✔ dplyr   1.1.0\n✔ tidyr   1.3.0     ✔ stringr 1.5.0\n✔ readr   2.1.3     ✔ forcats 0.5.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nemo <- read_csv(\"https://raw.githubusercontent.com/bodowinter/applied_statistics_book_data/master/warriner_2013_emotional_valence.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 13915 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): Word\ndbl (1): Val\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\num <- read_tsv(\"https://bit.ly/3JdeSbx\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 26060 Columns: 14\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \"\\t\"\nchr  (3): word, next_seg, idstring\ndbl (11): start_time, end_time, vowel_start, vowel_end, nasal_start, nasal_e...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\n## Discrete Probability distributions\n\nOur dice rolling experiment is an example of a discrete probability distribution. This code chunk plots the predicted probability of observing $n$ ⚀ or ⚅ on 10 rolls.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Define how many rolls\nnrolls <- 10\n\n## get the probability in a dataframe\ntibble(\n  ## possible observations\n  observed = 0:nrolls,\n  ## dbinom for the probability distribution\n  prob = dbinom(\n    ## possible observations\n    x = observed,\n    ## number of rolls\n    size = nrolls,\n    ## probability of success\n    prob = 2/6\n  )\n) |> \n  ## the plotting code\n  ggplot(aes(x = observed, y = prob))+\n    geom_col()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nIf we have more rolls, the range of probability density, relative to the whole range of possible observations, decreases.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Define how many rolls\nnrolls <- 1000\n\n## get the probability in a dataframe\ntibble(\n  ## possible observations\n  observed = 0:nrolls,\n  ## dbinom for the probability distribution\n  prob = dbinom(\n    ## possible observations\n    x = observed,\n    ## number of rolls\n    size = nrolls,\n    ## probability of success\n    prob = 2/6\n  )\n) |> \n  ## the plotting code\n  ggplot(aes(x = observed, y = prob))+\n    geom_col()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nWe can simulate the experiment, varying the number of groups who rolled different number of n times. Increasing the number of groups rolling a die fills in the density distribution more, but only increasing the number of *rolls* per group narrows the density range.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"complicated code just to make the plot\"}\nset.seed(611)\nexpand_grid(\n  nrolls = c(10, 100, 1000),\n  groups = c(5, 50, 500),\n  min = 0\n) |> \n  mutate(\n    expected = nrolls * (2/6)\n  )-> blank\n\n## Create all combinations of rolls\n## and number of groups\nexpand_grid(\n  nrolls = c(10, 100, 1000),\n  groups = c(5, 50, 500)\n) |> \n  ## We didn't learn about code like this,\n  ## using it just to make the graph\n  mutate(\n    roll_df = map2(\n      nrolls, \n      groups, \n      \\(roll, group) tibble(obs = rbinom(n = group, size = roll, prob = 2/6)))\n  ) |> \n  unnest(roll_df) |> \n  ggplot(aes(obs))+\n    stat_bin(binwidth = 1,\n             aes(y = after_stat(ndensity))) +\n    geom_blank(data = blank, aes(x = nrolls, y = 0))+\n    geom_blank(data = blank, aes(x = min, y = 0))+\n    geom_vline(data = blank, aes(xintercept = expected), color = \"steelblue\")+\n    facet_grid(groups~nrolls, \n               label = label_both,\n               scales = \"free\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"complicated code just to make the plot\"}\n# tibble(\n#   rand = rbinom(n = 500, size = nrolls, prob = 2/6)\n# ) |> \n#   ggplot(aes(x = rand)) +\n#     stat_bin(binwidth = 1)+\n#     geom_vline(xintercept = (2/6) * nrolls, color = \"red\")+\n#     expand_limits(x = c(0, nrolls))\n```\n:::\n\n\n## Normal Distribution\n\nThe \"Normal Distribution\" or \"Gaussian Distribution\" is a continuous probability density function. Rather than the height of the curve representing the \"point probability\" of a value, it represents an area that sums to 1. To get the probability of a value falling within a range of the normal distribution, you sum the area under the curve.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x = seq(-4, 4, length = 100),\n  dens = dnorm(x, mean = 0, sd = 1)\n) |>\n  ggplot(aes(x = x, y = dens)) +\n    geom_area()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\" code-summary=\"complex code just to make the plot\"}\none_sd_prob = round(pnorm(1) - pnorm(-1), digits = 2)\ntwo_four_prob = round(pnorm(4) - pnorm(2), digits = 2)\n\ntibble(\n  x = seq(-4, 4, length = 100),\n  dens = dnorm(x, mean = 0, sd = 1)\n) |>\n  ggplot(aes(x = x, y = dens)) +\n    geom_area() +\n    annotate(\n      ymin = -Inf,\n      ymax = Inf,\n      xmin = -1,\n      xmax = 1,\n      geom = \"rect\",\n      alpha = 0.3,\n      fill = \"steelblue\"\n    )+\n    annotate(\n      x = 0,\n      y = 0.2,\n      label = \n        str_wrap(\n          glue::glue(\"Area under the curve between -1 and 1 = {one_sd_prob}\"),\n          15\n        ),\n      geom = \"label\",\n      color = \"steelblue\"\n    )+\n    annotate(\n      ymin = -Inf,\n      ymax = Inf,\n      xmin = 2,\n      xmax = 4,\n      geom = \"rect\",\n      alpha = 0.3,\n      fill = \"#BE3455\"\n    )+\n    annotate(\n      x = 3,\n      y = 0.2,\n      label = \n        str_wrap(\n          glue::glue(\"Area under the curve between 2 and 4 = {two_four_prob}\"),\n          15\n        ),\n      geom = \"label\",\n      color = \"#BE3455\"\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nOne way to view how much area is under the curve, as you move from left to right, is to look at the \"cumulative probability function\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  prob = pnorm(\n    q = seq(-4, 4, length = 100),\n    mean = 0,\n    sd = 1\n  ),\n  x = seq(-4, 4, length = 100)\n) |> \n  ggplot(aes(x = x, y = prob))+\n    geom_area()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n## Real Data\n\nReal data is often a bit off from being normal, but might be normal-ish\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemo_xbar <- mean(emo$Val)\nemo_sd <- sd(emo$Val)\n\nemo |> \n  ggplot(aes(x = Val))+\n    stat_density()+\n    stat_function(\n      fun = dnorm,\n      args = list(mean = emo_xbar, sd = emo_sd),\n      color = \"steelblue\",\n      linewidth = 1) +\n    annotate(x = 7, y = 0.3,\n             label = \"empirical density\",\n             geom = \"label\") +\n    annotate(x = 2.5, y = 0.2,\n             label = \"normal density\",\n             geom = \"label\",\n             color = \"steelblue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n### Some definitions\n\nmean\n\n:   The sum of all values, divided by the number of observations\n\nmedian\n\n:   The value at which 50% of the data is less than it, and 50% is more.\n\nThe mean and median are the same for symmetrical distributions, like the normal distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(emo$Val)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.063847\n```\n:::\n\n```{.r .cell-code}\nmedian(emo$Val)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5.2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel <- lm(Val ~ 1, data = emo)\nsummary(model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = Val ~ 1, data = emo)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-3.8038 -0.8138  0.1362  0.8862  3.4662 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  5.06385    0.01081   468.5   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.275 on 13914 degrees of freedom\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}