{
  "hash": "bbc6acd448608d541b8c95bc9a215f48",
  "result": {
    "markdown": "---\ntitle: \"Basics of R Syntax\"\nauthor: Josef Fruehwald\ndate: 2023-01-17\ncategories:\n  - \"R basics\"\nerror: true\norder: 05\n---\n\n\n## Running R Code in a Quarto Notebook\n\nTo run R code in a Quarto notebook, you need to insert a \"code chunk\". In visual editor mode, you can do that by typing the forward slash (`/`) and start typing in \"R Code Chunk\". In the source editor mode, you have to have a line with ```` ```{r} ```` (three \"backticks\" followed by \"r\" in curly braces), then a few blank lines followed by another ```` ``` ````\n\n\n::: {.cell}\n\n````{.cell-code}\n```{{r}}\n1+1\n```\n````\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nTo actually run the code, you can either click on the green play button, or press the appropriate hotkey for your system (COMMAND+RETURN on a mac, CTRL+ENTER on windows).\n\n## Mathematical Operations\n\n### Addition\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 + 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 5\n```\n:::\n:::\n\n\n### Subtraction\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 - 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -3\n```\n:::\n:::\n\n\n### Multiplication\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 * 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n:::\n\n\n### Division\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 / 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.25\n```\n:::\n:::\n\n\n### Exponentiation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n5 ^ 4\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 625\n```\n:::\n:::\n\n\n### Orders of Operation\n\nHonestly, instead of gambling on how R may or may not interpret PEMDAS, just add parentheses `( )` around every operation in the order you want it to happen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(5 ^ (2 * 2)) / 6\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 104.1667\n```\n:::\n:::\n\n\n## Assignment\n\nTo assign values to a variable in R, you can use *either* `<-` or `->`. Most style guides shun `->`, but I actually wind up using it a lot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_variable <- 4 * 5\nprint(my_variable)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 20\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_variable / 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n:::\n\n\n## Data Types\n\n### Numeric\n\nWhen using a number in R, we can only use digits and dots (`.`). If we try to enter \"one hundred thousand\" with a comma separator, we'll get an error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbig_number <- 100,000\n```\n\n::: {.cell-output .cell-output-error}\n```\nError: <text>:1:18: unexpected ','\n1: big_number <- 100,\n                     ^\n```\n:::\n:::\n\n\nWe also can't use any percent signs (`%`) or currency symbols (`$`, `£`, `€`)\n\n### Characters\n\nWhen we type in text without any quotes, R will assume it's a variable or function that's already been defined and go looking for it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlarge <- 100000\nlarge\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1e+05\n```\n:::\n:::\n\n\nIf the variable hasn't been created already, we'll get an error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsmall\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'small' not found\n```\n:::\n:::\n\n\nIf we enter text inside of quotation marks, either single quotes `'` or double quotes `\"`, R will instead treat the text as a *value* that we could, for example, assign to a variable, or just print out.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"small\"\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"small\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntiny_synonym <- \"small\"\ntiny_synonym\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"small\"\n```\n:::\n:::\n\n\n::: {.callout-note appearance=\"simple\"}\n#### Common Error\n\nYou will *often* get confused about this and get the `Error: object '' not found` message. Even if you do this for 15 years, you will still sometimes enter plain text when you meant to put it in quotes, and put text in quotes you meant to enter without. It's always annoying, but doesn't mean you're bad at doing this.\n:::\n\n### Logical\n\nThere are two specialized values that you could call \"True/False\" or \"Logical\" or \"Boolean\" values\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# fullnames\nTRUE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nFALSE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Short Forms\nT\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nF\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nThese are often created using logical comparisons\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlarge  <- 100000\nmedium <-    600\n\nlarge < medium\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshort_word <- \"to\"\n\nnchar(short_word) == 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n:::\n\n\n### NA\n\nWhen you have a missing value, that's given a special `NA` value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnumbers <- c(1, NA, 5)\nnumbers\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  1 NA  5\n```\n:::\n:::\n\n\n## Vectors\n\nVectors are basically 1 dimensional lists of values.[^1] You can have numeric, character or logical vectors in R, but you can't mix types. One way to create vectors is with the `c()` (for **c**oncatenate) function. There needs to be a comma `,` between every value that you add to a vector.\n\n[^1]: The reason they aren't called \"lists\" is because there's another kind of data object called a list that has different properties.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndigital_words <- c(\n  \"-dle\",\n  \"BFFR\",\n  \"chief twit\",\n  \"chronically online\",\n  \"crypto rug pull\",\n  \"touch grass\",\n  \"-verse\"\n)\nprint(digital_words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"-dle\"               \"BFFR\"               \"chief twit\"        \n[4] \"chronically online\" \"crypto rug pull\"    \"touch grass\"       \n[7] \"-verse\"            \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndigital_word_votes <- c(\n  84,\n  14,\n  4,\n  30,\n  8,\n  64,\n  8\n)\nprint(digital_word_votes)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 84 14  4 30  8 64  8\n```\n:::\n:::\n\n\nYou can also create vectors of sequential vectors with the `:` operator.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1:10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1]  1  2  3  4  5  6  7  8  9 10\n```\n:::\n:::\n\n\n<details>\n\n<summary>More vector creating possibilities</summary>\n\nThere are a lot of functions for creating vectors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 1, to = 5, length = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1.000000 1.444444 1.888889 2.333333 2.777778 3.222222 3.666667 4.111111\n [9] 4.555556 5.000000\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nseq_along(digital_words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5 6 7\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(c(\"a\", \"b\"), times = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"b\" \"a\" \"b\" \"a\" \"b\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nrep(c(\"a\", \"b\"), each = 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"a\" \"a\" \"a\" \"b\" \"b\" \"b\"\n```\n:::\n:::\n\n\n</details>\n\n### Vector Arithmetic\n\nYou can do arithmetic on a whole vector of numbers. `digital_word_votes` is a vector of how many votes each word got. We can get the sum like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntotal_votes <- sum(digital_word_votes)\ntotal_votes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 212\n```\n:::\n:::\n\n\nThen, we can convert those vote counts to proportions by dividing them by the total.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndigital_word_votes / total_votes\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.39622642 0.06603774 0.01886792 0.14150943 0.03773585 0.30188679 0.03773585\n```\n:::\n:::\n\n\nAnd we can convert that to percentages by multiplying by 100.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(digital_word_votes / total_votes) * 100\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 39.622642  6.603774  1.886792 14.150943  3.773585 30.188679  3.773585\n```\n:::\n:::\n\n\n## Indexing\n\nIf you've never programmed before, this part will make sense, and if you haven't programmed before, this part will be confusing.\n\nIf you have a vector, and you want to get the first value from it, you put square brackets `[]` after the variable name, and put `1` inside.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprint(digital_words)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"-dle\"               \"BFFR\"               \"chief twit\"        \n[4] \"chronically online\" \"crypto rug pull\"    \"touch grass\"       \n[7] \"-verse\"            \n```\n:::\n\n```{.r .cell-code}\ndigital_words[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"-dle\"\n```\n:::\n:::\n\n\nIf you want a *range* of values from a vector, you can give it a vector of numeric indices.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndigital_words[2:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"BFFR\"               \"chief twit\"         \"chronically online\"\n[4] \"crypto rug pull\"   \n```\n:::\n:::\n\n\n### Logical Indexing\n\nAlso *really* useful is the ability to do logical indexing. For example, if we wanted to see which digital words got ten or fewer votes, we can do\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndigital_word_votes <= 10\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE FALSE  TRUE FALSE  TRUE\n```\n:::\n:::\n\n\nWe can use this sequence of `TRUE` and `FALSE` values to get the actual words from the `digital_words` vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndigital_words[digital_word_votes <= 10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"chief twit\"      \"crypto rug pull\" \"-verse\"         \n```\n:::\n:::\n\n\n## Data Frames\n\nThe *most* common kind of data structure we're going to be working with are Data Frames. These are two dimensional structures with rows and columns. The data types within each column all need to be the same.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_df <- data.frame(\n  type = \"digital\",\n  word = digital_words,\n  votes = digital_word_votes  \n)\nprint(word_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     type               word votes\n1 digital               -dle    84\n2 digital               BFFR    14\n3 digital         chief twit     4\n4 digital chronically online    30\n5 digital    crypto rug pull     8\n6 digital        touch grass    64\n7 digital             -verse     8\n```\n:::\n:::\n\n\n### Navigating data frames\n\nTo navigate data frames, there are a few handy functions. First, in RStudio you can launch a viewer with `View()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nView(word_df)\n```\n:::\n\n\nKeeping things inside the Quarto notebook, other useful functions are `summary()`, `nrow()`, `ncol()` and `colnames()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(word_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     type               word               votes      \n Length:7           Length:7           Min.   : 4.00  \n Class :character   Class :character   1st Qu.: 8.00  \n Mode  :character   Mode  :character   Median :14.00  \n                                       Mean   :30.29  \n                                       3rd Qu.:47.00  \n                                       Max.   :84.00  \n```\n:::\n\n```{.r .cell-code}\nnrow(word_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 7\n```\n:::\n\n```{.r .cell-code}\nncol(word_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 3\n```\n:::\n\n```{.r .cell-code}\ncolnames(word_df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"type\"  \"word\"  \"votes\"\n```\n:::\n:::\n\n\n### Indexing Data Frames\n\nTo get all of the data from a single column of a data frame, we can put `$` after the data frame variable name, then the name of the column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_df$word\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"-dle\"               \"BFFR\"               \"chief twit\"        \n[4] \"chronically online\" \"crypto rug pull\"    \"touch grass\"       \n[7] \"-verse\"            \n```\n:::\n:::\n\n\nWe're going to have more, interesting ways to get specific rows from a data frame later on in the course, but for now if you want to subset just the rows that have 10 or fewer votes, we can use `subset`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsubset(word_df, votes <= 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     type            word votes\n3 digital      chief twit     4\n5 digital crypto rug pull     8\n7 digital          -verse     8\n```\n:::\n:::\n\n\n<details>\n\n<summary>Pipe Preview</summary>\n\nThe \"pipe\" (`|>`) is going to play a big role in our R workflow. What it does is take whatever is on its left hand side and inserts it as the first argument to the function on the left hand side. Here's a preview.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nword_df |> \n  subset(votes <= 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     type            word votes\n3 digital      chief twit     4\n5 digital crypto rug pull     8\n7 digital          -verse     8\n```\n:::\n:::\n\n\n</details>\n\n## Packages\n\nPackages get installed once with `install.pacakges()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Only needs to be run once ever, or when updating\ninstall.packages(\"tidyverse\")\n```\n:::\n\n\nBut they need to be *loaded* every time with `library()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Needs to be run every time\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0     ✔ purrr   1.0.1\n✔ tibble  3.1.8     ✔ dplyr   1.1.0\n✔ tidyr   1.3.0     ✔ stringr 1.5.0\n✔ readr   2.1.3     ✔ forcats 0.5.2\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n:::\n\n\nIf you try to load a package that you haven't installed yet, you'll get this error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(fake_library)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in library(fake_library): there is no package called 'fake_library'\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}